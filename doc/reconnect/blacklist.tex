\documentclass{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{amsmath, amssymb}
\usepackage{mathpazo, times}

\newcommand{\sLam}[2]{\lambda {#1} \cdot {#2}}
\newcommand{\sApp}[2]{{#1} {#2}}
\newcommand{\sBind}[2]{{#1} \mathrel{\texttt{>}\!\!\texttt{>}\!\texttt{=}} {#2}}
\newcommand{\sReturn}{\mathtt{return}}

\newcommand{\sExpect}{\mathtt{expect}}
\newcommand{\sSend}{\mathtt{send}}
\newcommand{\sSpawn}{\mathtt{spawn}}
\newcommand{\sLink}{\mathtt{link}}
\newcommand{\sThrow}{\mathtt{throw}}
\newcommand{\sReconnect}{\mathtt{reconnect}}

\newcommand{\sSpawned}{\mathtt{spawned}}

\newcommand{\sExtend}[1]{\mathrel{\triangleright_{#1}}}

\newcommand{\sPar}{\mathrel{\parallel}}
\newcommand{\sParN}{\mathrel{{\parallel}_N}}
\newcommand{\sProc}[2]{{#1}_{#2}}

\newcommand{\sPid}{\ensuremath{\mathit{pid}}}
\newcommand{\sNid}{\ensuremath{\mathit{nid}}}
\newcommand{\sId}{\ensuremath{\mathit{id}}}
\newcommand{\sRef}{\ensuremath{\mathit{ref}}}

\newcommand{\sLinks}{\ensuremath{\mathit{links}}}
\newcommand{\sNode}[3]{\left[{#1} ; {#2}\right]_{#3}} 
\newcommand{\sSystem}[3]{\left\langle #1 ; #2 ; #3 \right\rangle}
\newcommand{\sNodes}{\mathcal{N}}
\newcommand{\sQueue}{\mathcal{Q}}
\newcommand{\sProcesses}{\mathcal{P}}
\newcommand{\sBlacklist}{\mathcal{B}}

\newcommand{\sJust}[1]{\mathtt{Just} \; {#1}}
\newcommand{\sNothing}{\mathtt{Nothing}}

\newcommand{\sCtxt}[1]{\mathbb{#1}}

\newcommand{\sSenders}{\mathit{senders}}

\newcommand{\OR}{\mathrel{|}}


\begin{document}

\title{Cloud Haskell Semantics}
\author{Edsko de Vries, Well-Typed LLP}
\date{\today}

\maketitle

\section{Syntax}

\subsection{Terms}

\begin{equation*}
\begin{array}{ll@{\;::=\;}l}
\text{value} & V    & \sLam{x}{M} \OR
                      \sExpect \OR
                      \sSend \; \sPid \; V \OR
                      \sSpawn \; \sNid \; V \OR 
                      \sReturn \; M
\\
\text{term}  & M, N & \sApp{M}{N} \OR
                      \sBind{M}{N}
\end{array}
\end{equation*}

\subsection{Processes, Nodes, Systems}

We assume two disjoint enumerable sets $\mathtt{ProcessId}$ and
$\mathtt{NodeId}$, ranged over by $\sPid$ and $\sNid$ and representing process
identifiers and node identifiers respectively. We do not need to refer to nodes
as entities in their own right in the semantics, but simply assume a total
function $$\mathtt{node} : \mathtt{ProcessId} \rightarrow \mathtt{NodeId}$$ We
also define $\mathtt{Identifier} = \mathtt{ProcessId} \uplus \mathtt{NodeId}$
and let $\sId$ range over $\mathtt{Identifier}$. 

We represent a process as a pair $\sProc{M}{\sPid}$ of a term $M$ and a process
ID $\sPid$. We will denote a set of processes as
%
  $$\sProc{M}{\sPid} \sPar \cdots \sPar \sProc{N}{\sPid'}$$
%
A \emph{system} 
  $\sSystem{\sProcesses}{\sQueue}{\sBlacklist}$ 
finally is a tuple containing a set $\sProcesses$ of nodes,
a \emph{system queue} $\sQueue$, and a \emph{blacklist} $\sBlacklist$.

The system queue is a set of triples $(\sId_\mathit{to}, \sId_\mathit{fr},
\mathit{message})$ of messages that have been sent but not yet processed. The
blacklist records disconnections and is represented as a of pairs
$(\sId_\mathit{to}, \sId_\mathit{fr})$. 

\section{Semantics}

\subsection{Contexts}

We define an evaluation context as usual (TODO: catch?)

\begin{equation*}
\sCtxt{E} ::= [] \OR \sBind{\sCtxt{E}}{M}
\end{equation*}

\subsection{Disconnect}

At the Cloud Haskell level we assume that \emph{nodes} get disconnected, not
individual processes. \emph{Reconnecting} however is on a per process basis. To
formalize this, let $\overline{\sNid}$ be the smallest set, given a set of
processes $\sProcesses$, such that
%
\begin{equation*}
\frac{
}{
\sNid \in \overline{\sNid}
} 
%
\qquad
%
\frac{
\sPid \in \sProcesses \qquad
\mathtt{node}(\sPid) = \sNid
}{
\sPid \in \overline{\sNid}
}
\end{equation*}

The following rule models random network disconnect between nodes $\sNid_1$ and
$\sNid_2$:

\begin{equation*}
\frac{
}{
  \sSystem{\sProcesses}{\sQueue}{\sBlacklist}
\rightarrow
  \sSystem{\sProcesses}{\sQueue}{\sBlacklist \cup (\overline{\sNid_1} \times \overline{\sNid_2})}
} \textsc{Disconnect}
\end{equation*}

However, connections to and from nodes can be implicitly reconnected:

\begin{equation*}
\frac{
}{
  \sSystem{\sProcesses}{\sQueue}{\sBlacklist, (\sNid_\mathit{to}, \sId_\mathit{fr})}
\rightarrow
  \sSystem{\sProcesses}{\sQueue}{\sBlacklist}
} \textsc{Recon-To}
\qquad
\frac{
}{
  \sSystem{\sProcesses}{\sQueue}{\sBlacklist, (\sId_\mathit{to}, \sNid_\mathit{fr})}
\rightarrow
  \sSystem{\sProcesses}{\sQueue}{\sBlacklist}
} \textsc{Recon-Fr}
\end{equation*}

Once a connection has been blacklisted, no further messages can be sent across
that connection (until an explicit or implicit reconnect). To model this we
introduce a function
%
\begin{equation*}
\begin{array}{l@{\;=\;}l@{\hspace{3em}}l}
  \sQueue \sExtend{\sBlacklist} (\sId_\mathit{to}, \sId_\mathit{fr}, M) 
& 
  \sQueue,  (\sId_\mathit{to}, \sId_\mathit{fr}, M)
&
  \text{if } (\sId_\mathit{to}, \sId_\mathit{fr}) \notin \sBlacklist
\\
  \sQueue \sExtend{\sBlacklist} (\sId_\mathit{to}, \sId_\mathit{fr}, M) 
& 
  \sQueue
&
  \text{otherwise}
\end{array}
\end{equation*}

\subsection{Process rules}

\subsubsection{Sending}

If the communication is blacklisted the send is a no-op.

\begin{equation*}
\frac{
}{
  \sSystem{   \sCtxt{E}[ \sSend \; \sPid_\mathit{to} \; M ]_{\sPid_\mathit{fr}} 
            \sPar
              \sProcesses
          }
          {\sQueue}
          {\sBlacklist}
\rightarrow 
  \sSystem{\sCtxt{E}[ \sReturn \; () ]_\mathit{fr} \sPar \sProcesses}
          {\sQueue \sExtend{\sBlacklist} (\sPid_\mathit{to}, \sPid_\mathit{fr}, M)}
          {\sBlacklist}
} \textsc{Send}
\end{equation*}

We ignore issues of serializability for the purposes of this semantics.

\subsubsection{Receiving}

We return the \emph{first} message of a randomly chosen sender.

\begin{equation*}
\frac{
  \sId_{\mathit{fr}} \notin \sSenders(\sQueue)
}{
  \sSystem{\sCtxt{E}[ \sExpect ]_{\sPid_\mathit{to}} \sPar \sProcesses}
          {\sQueue, (\sPid_\mathit{to}, \sId_\mathit{fr}, M), \sQueue'}
          {\sBlacklist}
\rightarrow
  \sSystem{\sCtxt{E}[ \sReturn \; M ]_{\sPid_\mathit{to}} \sPar \sProcesses}
          {\sQueue, \sQueue'}
          {\sBlacklist}
} \textsc{Expect}
\end{equation*}

\subsubsection{Spawning}

Spawning is asynchronous

\begin{equation*}
\frac{
  \text{\sRef fresh} 
}{
  \sSystem{\sCtxt{E}[ \sSpawn \; \sNid \; M ]_\sPid \sPar \sProcesses}
          {\sQueue}
          {\sBlacklist}
\rightarrow          
  \sSystem{\sCtxt{E}[ \sReturn \; \sRef ]_\sPid \sPar \sProcesses}
          {\sQueue \sExtend{\sBlacklist} (\sNid, \sPid, \sSpawn \; \sRef \; M)}
          {\sBlacklist}
} \textsc{Spawn-Async}
\end{equation*}


\begin{equation*}
\frac{
  \sPid \notin \sSenders(\sQueue)
\qquad
  \text{$\sPid'$ fresh}
}{
  \sSystem{\sProcesses}
          {\sQueue, (\sNid, \sPid, \sSpawn \; \sRef \; M), \sQueue'}
          {\sBlacklist}
\rightarrow
  \sSystem{\sProcesses \sPar M_{\sPid'}}
          {\sQueue, \sQueue' \sExtend{\sBlacklist} (\sPid, \sNid, \sSpawned \; \sRef \; \sPid')}
          {\sBlacklist}
} \textsc{Spawn-Reply}
\end{equation*}

\subsubsection{Reconnect}

\begin{equation*}
\frac{
}{
  \sSystem{\sCtxt{P}[ \sReconnect \; \sId_\mathit{to} ]_{\sPid_\mathit{fr}}}
          {\sQueue}
          {\sBlacklist}
\rightarrow
  \sSystem{\sCtxt{P}[ \sReturn \; () ]_\sPid}
          {\sQueue}
          {\sBlacklist \backslash (\sPid_\mathit{to}, \sPid_\mathit{fr})}
} \textsc{Reconnect}
\end{equation*}

\subsubsection{Administration}

TODO: bind, pure evaluation, maybe exception handling

\end{document}
