\documentclass{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{amsmath, amssymb}
\usepackage{mathpazo, times}

\newcommand{\sLam}[2]{\lambda {#1} \cdot {#2}}
\newcommand{\sApp}[2]{{#1} {#2}}
\newcommand{\sBind}[2]{{#1} \mathrel{\texttt{>}\!\!\texttt{>}\!\texttt{=}} {#2}}
\newcommand{\sReturn}{\mathtt{return}}

\newcommand{\sExpect}{\mathtt{expect}}
\newcommand{\sSend}{\mathtt{send}}
\newcommand{\sSpawn}{\mathtt{spawn}}
\newcommand{\sLink}{\mathtt{link}}
\newcommand{\sThrow}{\mathtt{throw}}
\newcommand{\sReconnect}{\mathtt{reconnect}}
\newcommand{\sNewChan}{\mathtt{newChan}}
\newcommand{\sSendChan}{\mathtt{sendChan}}
\newcommand{\sReceiveChan}{\mathtt{receiveChan}}
\newcommand{\sMonitor}{\mathtt{monitor}}

\DeclareMathOperator{\sNodeOf}{node}
\DeclareMathOperator{\sProcessOf}{process}

\newcommand{\sSpawned}{\mathtt{spawned}}

\newcommand{\sExtend}[1]{\mathrel{\triangleright_{#1}}}

\newcommand{\sPar}{\mathrel{\parallel}}
\newcommand{\sProc}[2]{{#1}_{#2}}

\newcommand{\sNid}{\ensuremath{\mathit{nid}}}
\newcommand{\sPid}{\ensuremath{\mathit{pid}}}
\newcommand{\sCid}{\ensuremath{\mathit{cid}}}

\newcommand{\sId}{\ensuremath{\mathit{id}}}
\newcommand{\sRef}{\ensuremath{\mathit{ref}}}

\newcommand{\sLinks}{\ensuremath{\mathit{links}}}
\newcommand{\sNode}[3]{\left[{#1} ; {#2}\right]_{#3}} 
\newcommand{\sSystem}[4]{\left\langle #1 ; #2 ; #3 ; #4 \right\rangle}
\newcommand{\sNodes}{\mathcal{N}}
\newcommand{\sQueue}{\mathcal{Q}}
\newcommand{\sProcesses}{\mathcal{P}}
\newcommand{\sBlacklist}{\mathcal{B}}
\newcommand{\sMonitors}{\mathcal{M}}

\newcommand{\sJust}[1]{\mathtt{Just} \; {#1}}
\newcommand{\sNothing}{\mathtt{Nothing}}

\newcommand{\sCtxt}[1]{\mathbb{#1}}

\newcommand{\sSenders}{\mathit{senders}}

\newcommand{\OR}{\mathrel{|}}


\begin{document}

\title{Cloud Haskell Semantics}
\author{Edsko de Vries, Well-Typed LLP}
\date{\today}

\maketitle

\section{Syntax}

\subsection{Terms}

\begin{equation*}
\begin{array}{ll@{\;::=\;}l}
\text{value} & V    & \sLam{x}{M} \OR
                      \sExpect \OR
                      \sSend \; \sPid \; M \OR
                      \sSpawn \; \sNid \; M \OR 
                      \sReturn \; M \OR
                      \cdots
\\
\text{term}  & M, N & \sApp{M}{N} \OR
                      \sBind{M}{N}
\end{array}
\end{equation*}

\subsection{Processes, Nodes, Systems}

We assume disjoint countable sets $\mathtt{NodeId}$, $\mathtt{ProcessId}$, and
$\mathtt{ChannelId}$, changed over by \sNid, \sPid{} and \sCid{} respectively,
and representing process identifiers, node identifiers, and (typed) channel
identifiers. We assume the existence of total functions
%
\begin{equation*}
\begin{array}{r@{\;:\;}l}
\sNodeOf    & (\mathtt{ProcessId} \uplus \mathtt{ChannelId}) \rightarrow \mathtt{NodeId} \\
\sProcessOf & \mathtt{ChannelId} \rightarrow \mathtt{ProcessId} 
\end{array}
\end{equation*}
%
and define 
$$\mathtt{Identifier} = \mathtt{NodeId} \uplus \mathtt{ProcessId} \uplus \mathtt{ChannelId}$$ 
and let $\sId$ range over $\mathtt{Identifier}$.

We represent a process as a pair $\sProc{M}{\sPid}$ of a term $M$ and a process
ID $\sPid$. We will denote a set of processes as
%
  $$\sProc{M}{\sPid} \sPar \cdots \sPar \sProc{N}{\sPid'}$$
%
A \emph{system} 
  $\sSystem{\sProcesses}{\sQueue}{\sBlacklist}{\sMonitors}$ 
is a tuple containing a set $\sProcesses$ of processes, a \emph{system
queue} $\sQueue$, a \emph{blacklist} $\sBlacklist$, and a set of monitors
$\sMonitors$.
The set of monitors $\sMonitors$ is a set of tuples 
  $(\sId_\mathit{to}, \sPid_\mathit{fr}, \sNid, \sRef)$ 
which records that the node controller at \sNid{} knows that process
$\sPid_\mathit{fr}$ is monitoring $\sId_\mathit{to}$ ($\sRef$ is the monitor
reference).
The system queue is a set of triples $(\sId_\mathit{to}, \sId_\mathit{fr},
\mathit{message})$ of messages that have been sent but not yet processed. The
blacklist records disconnections and is represented as a of pairs
$(\sId_\mathit{to}, \sId_\mathit{fr})$. 

%Note that we do not need to refer to nodes as entities in their own right in
%the semantics.

\section{Semantics}

\subsection{Contexts}

We define an evaluation context as usual (TODO: catch?)

\begin{align*}
\sCtxt{E} & ::= [] \OR \sBind{\sCtxt{E}}{M}  \\
\sCtxt{P}_\sPid  & ::= \sCtxt{E}[]_\sPid \sPar \sProcesses
\end{align*}

\subsection{Disconnect}

At the Cloud Haskell level we assume that \emph{nodes} get disconnected, not
individual processes. \emph{Reconnecting} however is on a per process basis. To
formalize this, let $\overline{\sNid}$ be the smallest set, given a set of
processes $\sProcesses$, such that
%
\begin{equation*}
\frac{
}{
\sNid \in \overline{\sNid}
} 
%
\qquad
%
\frac{
\sPid \in \sProcesses \qquad
\sNodeOf(\sPid) = \sNid
}{
\sPid \in \overline{\sNid}
}
%
\qquad
%
\frac{
\sCid \in \sProcesses \qquad
\sNodeOf(\sCid) = \sNid
}{
\sCid \in \overline{\sNid}
}
\end{equation*}

The following rule models random network disconnect between nodes $\sNid_1$ and
$\sNid_2$:

\begin{equation*}
\frac{
}{
  \sSystem{\sProcesses}{\sQueue}{\sBlacklist}{\sMonitors}
\rightarrow
  \sSystem{\sProcesses}{\sQueue}{\sBlacklist \cup (\overline{\sNid_1} \times \overline{\sNid_2})}{\sMonitors}
} \textsc{Disconnect}
\end{equation*}

We provide a primitive to remove a connection from the blacklist:

\begin{equation*}
\frac{
}{
  \sSystem{\sCtxt{P}[ \sReconnect \; \sId_\mathit{to} ]_{\sPid_\mathit{fr}}}
          {\sQueue}
          {\sBlacklist}
          {\sMonitors}
\rightarrow
  \sSystem{\sCtxt{P}[ \sReturn \; () ]_\sPid}
          {\sQueue}
          {\sBlacklist \backslash (\sId_\mathit{to}, \sPid_\mathit{fr})}
          {\sMonitors}
} \textsc{Recon-Ex}
\end{equation*}

Connections to and from nodes can be implicitly reconnected:

\begin{equation*}
\frac{
}{
  \sSystem{\sProcesses}{\sQueue}{\sBlacklist, (\sNid_\mathit{to}, \sId_\mathit{fr})}{\sMonitors}
\rightarrow
  \sSystem{\sProcesses}{\sQueue}{\sBlacklist}{\sMonitors}
} \textsc{Recon-Im1}
\qquad
\frac{
}{
  \sSystem{\sProcesses}{\sQueue}{\sBlacklist, (\sId_\mathit{to}, \sNid_\mathit{fr})}{\sMonitors}
\rightarrow
  \sSystem{\sProcesses}{\sQueue}{\sBlacklist}{\sMonitors}
} \textsc{Recon-Im2}
\end{equation*}

Once a connection has been blacklisted, no further messages can be sent across
that connection (until an explicit or implicit reconnect). To model this we
introduce a function
%
\begin{equation*}
\begin{array}{l@{\;=\;}l@{\hspace{3em}}l}
  \sQueue \sExtend{\sBlacklist} (\sId_\mathit{to}, \sId_\mathit{fr}, M) 
& 
  \sQueue,  (\sId_\mathit{to}, \sId_\mathit{fr}, M)
&
  \text{if } (\sId_\mathit{to}, \sId_\mathit{fr}) \notin \sBlacklist
\\
  \sQueue \sExtend{\sBlacklist} (\sId_\mathit{to}, \sId_\mathit{fr}, M) 
& 
  \sQueue
&
  \text{otherwise}
\end{array}
\end{equation*}
%
$(\sExtend{\sBlacklist})$ is only defined for serializable payloads.

\subsection{Process rules}

\subsubsection{Send and Receive}

\begin{equation*}
\frac{
}{
  \sSystem{\sCtxt{P}[ \sSend \; \sPid_\mathit{to} \; M ]_{\sPid_\mathit{fr}}}
          {\sQueue}
          {\sBlacklist}
          {\sMonitors}
\rightarrow 
  \sSystem{\sCtxt{P}[ \sReturn \; () ]_{\sPid_\mathit{fr}}}
          {\sQueue \sExtend{\sBlacklist} (\sPid_\mathit{to}, \sPid_\mathit{fr}, M)}
          {\sBlacklist}
          {\sMonitors}
} \textsc{Send}
\end{equation*}

We return the \emph{first} message of a randomly chosen sender.

\begin{equation*}
\frac{
  \sId_{\mathit{fr}} \notin \sSenders(\sQueue)
}{
  \sSystem{\sCtxt{P}[ \sExpect ]_{\sPid_\mathit{to}}}
          {\sQueue, (\sPid_\mathit{to}, \sId_\mathit{fr}, M), \sQueue'}
          {\sBlacklist}
          {\sMonitors}
\rightarrow
  \sSystem{\sCtxt{P}[ \sReturn \; M ]_{\sPid_\mathit{to}}}
          {\sQueue, \sQueue'}
          {\sBlacklist}
          {\sMonitors}
} \textsc{Expect}
\end{equation*}

\subsubsection{Spawning}

Spawning is asynchronous

\begin{equation*}
\frac{
  \sRef \text{ fresh} 
}{
  \sSystem{\sCtxt{P}[ \sSpawn \; \sNid \; M ]_\sPid}
          {\sQueue}
          {\sBlacklist}
          {\sMonitors}
\rightarrow          
  \sSystem{\sCtxt{P}[ \sReturn \; \sRef ]_\sPid}
          {\sQueue \sExtend{\sBlacklist} (\sNid, \sPid, \sSpawn \; \sRef \; M)}
          {\sBlacklist}
          {\sMonitors}
} \textsc{Spawn-Async}
\end{equation*}

\begin{equation*}
\frac{
  \sPid \notin \sSenders(\sQueue)
\qquad
  \sPid' \text{ fresh} 
\qquad
  \sNodeOf(\sPid') = \sNid
}{
  \sSystem{\sProcesses}
          {\sQueue, (\sNid, \sPid, \sSpawn \; \sRef \; M), \sQueue'}
          {\sBlacklist}
          {\sMonitors}
\rightarrow
  \sSystem{\sProcesses \sPar M_{\sPid'}}
          {\sQueue, \sQueue' \sExtend{\sBlacklist} (\sPid, \sNid, \sSpawned \; \sRef \; \sPid')}
          {\sBlacklist}
          {\sMonitors}
} \textsc{Spawn-Reply}
\end{equation*}

\subsubsection{Typed Channels}

Since the semantics is not type-driven, we represent typed channels simply as
an identifier with an annotation whether it is the send-end ($\sCid^s$) or the
receive end ($\sCid^r$) of the channel.

\begin{equation*}
\frac{
  \sCid \text{ fresh}
\qquad
  \sProcessOf(\sCid) = \sPid
}{
  \sSystem{\sCtxt{P}[\sNewChan]_\sPid}
          {\sQueue}
          {\sBlacklist}
          {\sMonitors}
\rightarrow
  \sSystem{\sCtxt{P}[\sReturn \; (\sCid^s, \sCid^r)]_\sPid}
          {\sQueue}
          {\sBlacklist}
          {\sMonitors}
} \textsc{NewChan}
\end{equation*}

\begin{equation*}
\frac{
}{
  \sSystem{\sCtxt{P}[ \sSendChan \; \sCid_\mathit{to}^s \; M ]_{\sPid_\mathit{fr}}}
          {\sQueue}
          {\sBlacklist}
          {\sMonitors}
\rightarrow 
  \sSystem{\sCtxt{P}[ \sReturn \; () ]_{\sPid_\mathit{fr}}}
          {\sQueue \sExtend{\sBlacklist} (\sCid_\mathit{to}, \sPid_\mathit{fr}, M)}
          {\sBlacklist}
          {\sMonitors}
} \textsc{SendChan}
\end{equation*}

\begin{equation*}
\frac{
  \sPid_{\mathit{fr}} \notin \sSenders(\sQueue)
}{
  \sSystem{\sCtxt{P}[ \sReceiveChan \; \sCid_\mathit{to}^r ]_{\sPid}}
          {\sQueue, (\sCid_\mathit{to}, \sPid_\mathit{fr}, M), \sQueue'}
          {\sBlacklist}
          {\sMonitors}
\rightarrow
  \sSystem{\sCtxt{P}[ \sReturn \; M ]_{\sPid}}
          {\sQueue, \sQueue'}
          {\sBlacklist}
          {\sMonitors}
} \textsc{ReceiveChan}
\end{equation*}

\subsubsection{Monitoring}

The local node controller is notified immediately of the new monitor, and the
remote monitor is sent a message (which may, of course, be lost). 

\begin{equation*}
\frac{
  \sNid_\mathit{fr} = \sNodeOf(\sPid_\mathit{fr}) 
\qquad
  \sNid_\mathit{to} = \sNodeOf(\sId_\mathit{to})
\qquad
  \sRef \text{ fresh}
}{
\begin{array}{ll}
& \sSystem{\sCtxt{P}[ \sMonitor \; \sId_\mathit{to} ]_{\sPid_\mathit{fr}}}
          {\sQueue}
          {\sBlacklist}
          {\sMonitors}
\\         
\rightarrow &
  \sSystem{\sCtxt{P}[ \sReturn \; \sRef ]_{\sPid_\mathit{fr}}}
          {\sQueue \sExtend{\sBlacklist} (\sNid_\mathit{to}, \sPid_\mathit{fr}, \sMonitor \; \sRef \; \sId_\mathit{to})}
          {\sBlacklist}
          {\sMonitors, (\sId_\mathit{to}, \sPid_\mathit{fr}, \sNid_\mathit{fr}, \sRef)}
\end{array}
} \textsc{Monitor}
\end{equation*}

\begin{equation*}
\frac{
  \sPid_\mathit{fr} \notin \sSenders(\sQueue)
}{
  \sSystem{\sProcesses}
          {\sQueue, (\sNid_\mathit{to}, \sPid_\mathit{fr}, \sMonitor \; \sRef \; \sId_\mathit{to}), \sQueue'}
          {\sBlacklist}
          {\sMonitors}
\rightarrow          
  \sSystem{\sProcesses}
          {\sQueue, \sQueue'}
          {\sBlacklist}
          {\sMonitors, (\sId_\mathit{to}, \sPid_\mathit{fr}, \sNid_\mathit{to}, \sRef)}
} \textsc{Monitor-Remote}
\end{equation*}

The \emph{local} node controller notifies a monitoring process when it gets
disconncted from a monitored remote process.

\begin{equation*}
\frac{
  \sNid_\mathit{fr} = \sNodeOf(\sPid_\mathit{fr})
\qquad
  (\sId_\mathit{to}, \sPid_\mathit{fr}) \in \sBlacklist
}{
  \sSystem{\sProcesses}
          {\sQueue}
          {\sBlacklist}
          {\sMonitors, (\sId_\mathit{to}, \sPid_\mathit{fr}, \sNid_\mathit{fr}, \sRef)}
\rightarrow          
  \sSystem{\sProcesses}
          {\sQueue, (\sPid_\mathit{fr}, \sId_\mathit{to}, \mathtt{discon} \; \sRef)}
          {\sBlacklist}
          {\sMonitors}
} \textsc{Discon}
\end{equation*}

\subsubsection{Process Termination}

We remove a terminated process only once all its monitors have been notified.

\begin{equation*}
\frac{
  \sNodeOf(\sPid) = \sNid
\qquad
  \nexists \; \sPid', \sRef \cdot (\sPid', \sPid, \sNid, \sRef) \in \sMonitors 
}{
  \sSystem{{(\sReturn \; ())}_\sPid \sPar \sProcesses}
          {\sQueue}
          {\sBlacklist}
          {\sMonitors}
\rightarrow          
  \sSystem{\sProcesses}
          {\sQueue}
          {\sBlacklist}
          {\sMonitors}
} \textsc{Term}
\end{equation*}

The \emph{remote} node controller notifies a monitoring process when its
monitored remote process terminates.

\begin{equation*}
\frac{
  \sNodeOf(\sPid) = \sNid
}{
  \sSystem{{(\sReturn \; ())}_\sPid \sPar \sProcesses}
          {\sQueue}
          {\sBlacklist}
          {\sMonitors, (\sPid, \sPid', \sNid, \sRef)}
\rightarrow
  \sSystem{{(\sReturn \; ())}_\sPid \sPar \sProcesses}
          {\sQueue \sExtend{\sBlacklist} (\sPid', \sPid, \mathtt{died} \; \sRef)}
          {\sBlacklist}
          {\sMonitors}
} \textsc{Died}
\end{equation*}

\subsubsection{Administration}

TODO: bind, pure evaluation, maybe exception handling

\end{document}
