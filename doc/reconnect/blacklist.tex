\documentclass{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{amsmath, amssymb}
\usepackage{mathpazo, times}

\newcommand{\sLam}[2]{\lambda {#1} \cdot {#2}}
\newcommand{\sApp}[2]{{#1} {#2}}
\newcommand{\sBind}[2]{{#1} \mathrel{\texttt{>}\!\!\texttt{>}\!\texttt{=}} {#2}}
\newcommand{\sReturn}{\mathtt{return}}

\newcommand{\sExpect}{\mathtt{expect}}
\newcommand{\sSend}{\mathtt{send}}
\newcommand{\sSpawn}{\mathtt{spawn}}
\newcommand{\sLink}{\mathtt{link}}
\newcommand{\sThrow}{\mathtt{throw}}
\newcommand{\sReconnect}{\mathtt{reconnect}}

\newcommand{\sPar}{\mathrel{{\parallel}_P}}
\newcommand{\sParN}{\mathrel{{\parallel}_N}}
\newcommand{\sProc}[2]{{#1}_{#2}}

\newcommand{\sPid}{\ensuremath{\mathit{pid}}}
\newcommand{\sNid}{\ensuremath{\mathit{nid}}}
\newcommand{\sId}{\ensuremath{\mathit{id}}}

\newcommand{\sLinks}{\ensuremath{\mathit{links}}}
\newcommand{\sNode}[3]{\left[{#1} ; {#2}\right]_{#3}} 
\newcommand{\sSystem}[3]{\left\langle #1 ; #2 ; #3 \right\rangle}
\newcommand{\sNodes}{\mathcal{N}}
\newcommand{\sQueue}{\mathcal{Q}}
\newcommand{\sProcesses}{\mathcal{P}}
\newcommand{\sBlacklist}{\mathcal{B}}

\newcommand{\sJust}[1]{\mathtt{Just} \; {#1}}
\newcommand{\sNothing}{\mathtt{Nothing}}

\newcommand{\sCtxt}[1]{\mathbb{#1}}

\newcommand{\sSenders}{\mathit{senders}}

\newcommand{\OR}{\mathrel{|}}


\begin{document}

\title{Cloud Haskell Semantics}
\author{Edsko de Vries, Well-Typed LLP}
\date{\today}

\maketitle

\section{Syntax}

\subsection{Terms}

\begin{equation*}
\begin{array}{ll@{\;::=\;}l}
\text{value} & V    & \sLam{x}{M} \OR
                      \sExpect \OR
                      \sSend \; \sPid \; V \OR
                      \sSpawn \; \sNid \; V \OR 
                      \sReturn \; M
\\
\text{term}  & M, N & \sApp{M}{N} \OR
                      \sBind{M}{N}
\end{array}
\end{equation*}

\subsection{Processes, Nodes, Systems}

We assume two disjoint enumerable sets $\mathtt{ProcessId}$ and
$\mathtt{NodeId}$, ranged over by $\sPid$ and $\sNid$ and representing process
identifiers and node identifiers respectively. We do not need to refer to nodes
as entities in their own right in the semantics, but simply assume a total
function $$\mathtt{node} : \mathtt{ProcessId} \rightarrow \mathtt{NodeId}$$ We
also define $\mathtt{Identifier} = \mathtt{ProcessId} \uplus \mathtt{NodeId}$
and let $\sId$ range over $\mathtt{Identifier}$. 

We represent a process as a pair $\sProc{M}{\sPid}$ of a term $M$ and a process
ID $\sPid$. We will denote a set of processes as
%
  $$\sProc{M}{\sPid} \sPar \cdots \sPar \sProc{N}{\sPid'}$$
%
A \emph{system} 
  $\sSystem{\sProcesses}{\sQueue}{\sBlacklist}$ 
finally is a tuple containing a set $\sProcesses$ of nodes,
a \emph{system queue} $\sQueue$, and a \emph{blacklist} $\sBlacklist$.

The system queue is a set of triples $(\sId_\mathit{to}, \sId_\mathit{fr},
\mathit{message})$ of messages that have been sent but not yet processed. The
blacklist records disconnections and is represented as a of pairs
$(\sId_\mathit{to}, \sId_\mathit{fr})$. 

\section{Semantics}

\subsection{Contexts}

We define an evaluation context as usual (TODO: catch?)

\begin{equation*}
\sCtxt{E} ::= [] \OR \sBind{\sCtxt{E}}{M}
\end{equation*}

A process context, parametrized by a \sPid, identifies a process within a set
of nodes. 

\begin{equation*}
\sCtxt{P}_\sPid ::= \sNode{\sProc{\sCtxt{E}}{pid} \sPar \sProcesses}{\sLinks}{\sNid} \sParN \sNodes 
\end{equation*}

We also find it useful to have a process context with two holes, one for a
process identified by \sPid{} and one for the set of processes on node \sNid.
This set of processes may or may not live on the same node as \sPid. 

\begin{equation*}
\begin{array}{rl}
\sCtxt{P}_{\sPid,\sNid} ::= & 
  \sNode{\sProc{\sCtxt{E}}{pid} \sPar []}{\sLinks}{\sNid} \sParN \sNodes \\[1em]
\OR & 
  \sNode{\sProc{\sCtxt{E}}{pid} \sPar \sProcesses}{\sLinks}{\sNid'} \sParN \sNode{[]}{\sLinks}{\sNid} \sParN \sNodes 
    \qquad
  (\sNid \neq \sNid')
\end{array}
\end{equation*}

\subsection{System Rules}

At the Cloud Haskell level we assume that \emph{nodes} get disconnected, not
individual processes. To formalize this, let $\overline{\sNid}$ be the smallest
set, given a set of processes $\sProcesses$, such that
%
\begin{equation*}
\frac{
}{
\sNid \in \overline{\sNid}
} 
%
\qquad
%
\frac{
\sPid \in \sProcesses \qquad
\mathtt{node}(\sPid) = \sNid
}{
\sPid \in \overline{\sNid}
}
\end{equation*}

The following rule models random network disconnect between nodes $\sNid_1$ and
$\sNid_2$:

\begin{equation*}
\frac{
}{
  \sSystem{\sProcesses}{\sQueue}{\sBlacklist}
\rightarrow
  \sSystem{\sProcesses}{\sQueue}{\sBlacklist \cup (\overline{\sNid_1} \times \overline{\sNid_2})}
} \textsc{Disconnect}
\end{equation*}

However, connections to and from nodes can be implicitly reconnected:

\begin{equation*}
\frac{
}{
  \sSystem{\sProcesses}{\sQueue}{\sBlacklist, (\sNid_\mathit{to}, \sId_\mathit{fr})}
\rightarrow
  \sSystem{\sProcesses}{\sQueue}{\sBlacklist}
} \textsc{Recon-To}
\qquad
\frac{
}{
  \sSystem{\sProcesses}{\sQueue}{\sBlacklist, (\sId_\mathit{to}, \sNid_\mathit{fr})}
\rightarrow
  \sSystem{\sProcesses}{\sQueue}{\sBlacklist}
} \textsc{Recon-Fr}
\end{equation*}

\subsection{Process rules}

\subsubsection{Sending}

If the communication is blacklisted the send is a no-op.

\begin{equation*}
\frac{
(\mathit{to}, \mathit{fr}) \notin \sBlacklist
}{
  \sSystem{\sCtxt{P}[ \sSend \; \mathit{to} \; V ]_\mathit{fr}}
          {\sQueue}
          {\sBlacklist}
\rightarrow 
  \sSystem{\sCtxt{P}[ \sReturn \; () ]_\mathit{fr}}
          {\sQueue, (\mathit{to}, \mathit{fr}, V)}
          {\sBlacklist}
} \textsc{Send-Ok}
\end{equation*}

\begin{equation*}
\frac{
(\mathit{to}, \mathit{fr}) \in \sBlacklist
}{
  \sSystem{\sCtxt{P}[ \sSend \; \mathit{to} \; V ]_\mathit{fr}}
          {\sQueue}
          {\sBlacklist}
\rightarrow 
  \sSystem{\sCtxt{P}[ \sReturn \; () ]_\mathit{fr}}
          {\sQueue}
          {\sBlacklist}
} \textsc{Send-No}
\end{equation*}

TODO: this allows to send functions

\subsubsection{Receiving}

We return the \emph{first} message of a randomly chosen sender.

\begin{equation*}
\frac{
  \mathit{fr} \notin \sSenders(\sQueue)
}{
  \sSystem{\sCtxt{P}[ \sExpect ]_\mathit{fr}}
          {\sQueue, (\mathit{to}, \mathit{fr}, V), \sQueue'}
          {\sBlacklist}
\rightarrow
  \sSystem{\sCtxt{P}[ \sReturn \; V ]_\mathit{fr}}
          {\sQueue, \sQueue'}
          {\sBlacklist}
} \textsc{Expect}
\end{equation*}

\subsubsection{Spawning}

\begin{equation*}
\frac{
  \sPid' \text{ fresh} \qquad
  (\sNid, \sPid) \notin \sBlacklist
}{
  \sSystem{\sCtxt{P}[ \sSpawn \; \sNid \; M ]_\sPid[\sProcesses]_\sNid}
          {\sQueue}
          {\sBlacklist}
\rightarrow          
  \sSystem{\sCtxt{P}[ \sReturn \; (\sJust{\sPid'}) ]_\sPid[\sProcesses \sPar M_{\sPid'}]_\sNid}
          {\sQueue}
          {\sBlacklist}
} \textsc{Spawn-Ok}
\end{equation*}

\begin{equation*}
\frac{
  (\sNid, \sPid) \in \sBlacklist
}{
  \sSystem{\sCtxt{P}[ \sSpawn \; \sNid \; M ]_\sPid}
          {\sQueue}
          {\sBlacklist}
\rightarrow          
  \sSystem{\sCtxt{P}[ \sReturn \; \sNothing ]_\sPid}
          {\sQueue}
          {\sBlacklist}
} \textsc{Spawn-No}
\end{equation*}

\subsubsection{Reconnect}

\begin{equation*}
\frac{
}{
  \sSystem{\sCtxt{P}[ \sReconnect \; \mathit{id} ]_\sPid}
          {\sQueue}
          {\sBlacklist, (\mathit{id}, \sPid), \sBlacklist'}
\rightarrow
  \sSystem{\sCtxt{P}[ \sReturn \; () ]_\sPid}
          {\sQueue}
          {\sBlacklist, \sBlacklist'}
} \textsc{Reconnect-Ok}
\end{equation*}

\begin{equation*}
\frac{
  (\mathit{id}, \sPid) \notin \sBlacklist
}{
  \sSystem{\sCtxt{P}[ \sReconnect \; \mathit{id} ]_\sPid}
          {\sQueue}
          {\sBlacklist}
\rightarrow
  \sSystem{\sCtxt{P}[ \sReturn \; () ]_\sPid}
          {\sQueue}
          {\sBlacklist}
} \textsc{Reconnect-No}
\end{equation*}

\subsubsection{Administration}

TODO: bind, pure evaluation, maybe exception handling

\end{document}
